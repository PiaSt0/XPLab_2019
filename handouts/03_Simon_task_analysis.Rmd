---
title: "Simon Task - Data exploration"
output: rmdformats::material
---
```{r setup, include=FALSE, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(echo=TRUE, 
                      warning=FALSE,
                      message=FALSE, 
                      collapse = TRUE,
                      cache = TRUE,
                      dev.args = list(bg = 'transparent'), 
                      fig.align='center', 
                      fig.height = 3, 
                      fig.widht=4)
require(rmdformats)
require(tidyverse)
require(brms)
options(mc.cores = parallel::detectCores())

theme_set(theme_bw() + theme(plot.background=element_blank()) )
```


```{r, echo = FALSE}
d <- read_csv("03_Simon_data_anonym.csv")
```


# Background: the Simon task

The Simon task is pretty cool. The task is designed to see if responses are faster and/or more accurate when the stimulus to respond to occurs in the same relative location as the response, even if the stimulus location is irrelevant to the task. For example, it is faster to respond to a stimulus presented on the left of the screen with a key that is on the left of the keyboard (e.g. `q`), than with a key that is on the right of the keyboard (e.g. `p`).

# Experiment

## Participants 

A total of `r d$submission_id %>% unique %>% length` participants took part in an online version of a Simon task. Participants were students enrolled in either "Introduction to Cognitive (Neuro-)Psychology" (N = `r filter(d, class == "Intro Cogn. Neuro-Psychology") %>% pull(submission_id) %>% unique %>% length`), or "Experimental Psychology Lab Practice" (N = `r filter(d, class == "Experimental Psych Lab") %>% pull(submission_id) %>% unique %>% length`) or both (N = `r filter(d, class == "both") %>% pull(submission_id) %>% unique %>% length`). 

## Materials & Design

Each trial started by showing a fixation cross for 200 ms in the center of the screen. Then, one of two geometrical shapes was shown for 500 ms. The **target shape** was either a blue square or a blue circle. The target shape appeared either on the left or right of the screen. Each trial determined uniformly at random which shape (square or circle) to show as target and where on the screen to display it (left or right). Participants where instructed to press keys `q` (left of keyboard) or `p` (right of keyboard) to identify the kind of shape on the screen. The shape-key allocation happened experiment initially, uniformly at random once for each participant and remained constant throughout the experiment. For example, a participant may have been asked to press `q` for square and `p` for circle.

Trials were categorized as either 'congruent' or 'incongruent'. They were congruent if the location of the stimulus was the same relative location as the response key (e.g. square on the right of the screen, and `p` key to be pressed for square) and incongruent if the stimulus was not in the same relative location as the response key (e.g. square on the right and `q` key to be pressed for square).

In each trial, if no key was pressed within 3 seconds after the appearance of the target shape, a message to please respond faster was displayed on screen.

## Procedure

Participants were first welcomed and made familiar with the experiment. They were told to optimize both speed and accuracy. They then practiced the task for 20 trials before starting the main task, which consisted of 100 trials. Finally, the experiment ended with a post-test survey in which participants were asked for their student IDs and the class they were enrolled in. They were also able to leave any optional comments.

# Results

## Loading and inspecting the data

We load the data into R and show a summary of the variables stored in the tibble:


```{r}
d <- read_csv("03_Simon_data_anonym.csv")
glimpse(d)
```

It is often useful to check general properties, such as the mean time participants spent on the experiment:

```{r}
d %>% pull(timeSpent) %>% mean()
```

About `r d %>% pull(timeSpent) %>% mean() %>% round(2)` minutes is quite long, but we know that the mean is very susceptible to outliers, so we may want to look at a more informative set of **summary statistics**:

```{r}
d %>% pull(timeSpent) %>% summary()
```

**HW1:** Make a histogram of the `timeSpent`.

## Summarizing & cleaning the data

We look at outlier-y behavior at the level of individual participants first, then at the level of individual trials.

### Individual-level error rates & reaction times

It is conceivable that some participants did not take the task seriously. They may have just fooled around. We will therefore inspect each individual's response patterns and reaction times. If participants appear to have "misbehaved" we discard all of their data. (**CAVEAT:** Notice the researcher degrees of freedom in the decision of what counts as "misbehavior"! It is therefore that choices like these are best committed to in advance, e.g. via pre-registration!)

We can calculate the mean reaction times and the error rates for each participant.

```{r}
d_individual_summary <- d %>% 
  filter(trial_type == "main") %>%    # look at only data from main trials
  group_by(submission_id) %>%         # calculate the following for each individual
  summarize(mean_RT = mean(RT),
            error_rate = 1 - mean(ifelse(correctness == "correct", 1, 0)))
head(d_individual_summary)
```

Let's plot this summary information:

```{r}
d_individual_summary %>% 
  ggplot(aes(x = mean_RT, y = error_rate)) +
  geom_point()
```

Here's a crude way of branding outlier-participants:

```{r}
d_individual_summary <- d_individual_summary %>% 
  mutate(outlier = case_when(mean_RT < 350 ~ TRUE,
                             mean_RT > 750 ~ TRUE,
                             error_rate > 0.5 ~ TRUE,
                             TRUE ~ FALSE))
d_individual_summary %>% 
  ggplot(aes(x = mean_RT, y = error_rate)) +
  geom_point() +
  geom_point(data = filter(d_individual_summary, outlier == TRUE),
             color = "firebrick", shape = "square", size = 5)

```

We then clean the data set in a first step by removing all participants identified as outlier-y:

```{r, message=TRUE}
d <- full_join(d, d_individual_summary, by = "submission_id") # merge the tibbles
d <- filter(d, outlier == FALSE)
message("We excluded ", sum(d_individual_summary$outlier) , " participants for suspicious mean RTs and higher error rates.")
```


### Trial-level reaction times

It is also conceivable that inidividual trials resulted in early accidental key presses or were interrupted in some way or another. We therefore look at the overall distribution of RTs and determine (similarly arbitrarily, but once again this should be planned in advance) what to exclude.

```{r}
d %>% ggplot(aes(x = log(RT))) +
  geom_histogram() +
  geom_jitter(aes(x = log(RT), y = 1), alpha = 0.3, height = 300)
```


Let's decide to exclude all trials that lasted longer than 1 second and also all trials with reaction times under 100 ms.

```{r}
d <- filter(d, RT > 100 & RT < 1000)
d %>% ggplot(aes(x = RT)) +
  geom_histogram() +
  geom_jitter(aes(x = RT, y = 1), alpha = 0.3, height = 300)
```


## Exploring the (main) data

We are mostly interested in the influence of congruency on the reactions times in the trials where participants gave a correct answer. But here we also look at, for comparison, the reaction times for the incongruent trials.

Here is a summary of the means and standard deviations for each condition:

```{r}
d_sum <- d %>% 
  group_by(correctness, condition) %>% 
  summarize(mean_RT = mean(RT),
            sd_RT = sd(RT))
d_sum
```

Here's a plot of the reaction times split up by whether the answer was correct and whether the trial was congruent or incongruent. 

```{r}
d %>% ggplot(aes(x = RT)) +
  geom_jitter(aes(y = 0.0005), alpha = 0.1, height = 0.0005) +
  geom_density(fill = "gray", alpha = 0.5) +
  geom_vline(data = d_sum, 
             mapping = aes(xintercept = mean_RT), 
             color = "firebrick") +
  facet_grid(condition ~ correctness)
```


## To be continued (for homework)
The analysis above is very preliminary. We could do many more things (which we should pre-register or be explicit that they are exploratory). For example,
the responses made by students enrolled in the different classes could differ.
In the dataframe, there is a column `class`, which we could use to split the data into two groups to compare them (we already did this once when we described the sample).

For example:
```{r}
d %>% filter(class == "Experimental Psych Lab") # filters the students only enrolled in Experimental Psych Lab

d %>% filter(class == "Intro Cogn. Neuro-Psychology") # filters the students only enrolled in Experimental Psych Lab

d %>% filter(class == "both") # filters the students enrolled in both classes
```